#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

#define SIZE 10
#define SHIP_COUNT 4
#define MAX_RADAR_SWEEPS 3

typedef struct
{
    int shipBoard[SIZE][SIZE];
    char board[SIZE][SIZE];          // Player's own board
    char displayBoard[SIZE][SIZE];   // Opponent's view
    bool shipsAvailable[SHIP_COUNT]; // Helps with placing ships
    bool obscuredCells[SIZE][SIZE];  // Hides cells when Smoke Screen applied
    // Abilities
    int radarSweeps;
    int smokeScreens;
    // Counter for how many ships the player controlling has sunk
    int shipsSunk;
    // Counter for how many smoke screens the player has used
    int smokeCount;
    // Counter used in torpedo condition.
    int counter;
    // Counters used for artillery to work as indicated
    int shipOneCounter;
    int shipTwoCounter;
    int shipThreeCounter;
    // Indicates if you can use certain ability
    bool canUseArtillery;
    bool canUseTorpedo;
} PlayerStatus;

typedef struct
{
    int lastHitX;       // Tracks last hit X coordinate
    int lastHitY;       // Tracks last hit Y coordinate
    bool targetingMode; // True if focusing on a specific ship, false initially
} BotStatus;

enum ShipSize
{
    CARRIER = 5,
    BATTLESHIP = 4,
    DESTROYER = 3,
    SUBMARINE = 2
};
BotStatus botStatus = {-1, -1, false};
int botBoard[SIZE][SIZE] = {0};

// FUNCTION HEADERS
void getPlayerName(char name[20]);
int getDifficulity(char difficulity[]);
void initializeBoard(char board[SIZE][SIZE]);
void initializeShipBoard(int shipBoard[SIZE][SIZE]);
void printBoard(char board[SIZE][SIZE]);
void displayAvailableShips(PlayerStatus playerStatus[], int player);
void placeShip(char board[SIZE][SIZE], int shipBoard[SIZE][SIZE], enum ShipSize size);
void displayAvailableMoves(PlayerStatus playerStatus[], int player, int bot);
bool attack(char board[SIZE][SIZE], char displayBoard[SIZE][SIZE], int x, int y); // Attack method is bool to keep track of hits and misses (useful in bot imp.)
bool radarSweep(PlayerStatus playerStatus[], int bot, int x, int y);
bool smokeScreen(PlayerStatus playerStatus[], int player, int x, int y);
void artillery(char opponentBoard[SIZE][SIZE], char displayBoard[SIZE][SIZE], int x, int y);
void torpedo(char opponentBoard[SIZE][SIZE], char displayBoard[SIZE][SIZE], char *input);
void checkSunkShips(PlayerStatus playerStatus[], int player, int bot);
bool checkWin(char opponentBoard[SIZE][SIZE]);
void printBot(int shipBoard[SIZE][SIZE]);

// Helper/Secondary Methods
void clearScreen();
int randomFirstPlayer();
void waitFor(unsigned int secs);
bool validateCoordinates(int x, int y);
bool checkPlacement(char board[SIZE][SIZE], int x, int y, int size, bool horizontal);
void displayMoveCatalogue();
// PHASE 2
void placeBotShip(char board[SIZE][SIZE], int shipBoard[SIZE][SIZE], int size);
void botEasy(PlayerStatus playerStatus[], int player, int bot);
void botMedium(PlayerStatus playerStatus[], int player, int bot);
char *randomTorpedo();
char *randomTorpedoo(int lastHitX, int lastHitY);

int main()
{
    // Global initialization
    clearScreen();
    srand(time(NULL));
    PlayerStatus playerStatus[2];
    char name[20];
    int randomNumber;
    char difficulity[2];
    getPlayerName(name);
    int diff = getDifficulity(difficulity);
    // PlayerStatus Bot;
    //  PlayerStatus initialization phase
    for (int i = 0; i < 2; i++)
    {
        playerStatus[i].radarSweeps = MAX_RADAR_SWEEPS;
        playerStatus[i].smokeScreens = 0;
        playerStatus[i].smokeCount = 0;
        playerStatus[i].counter = 0;
        playerStatus[i].shipOneCounter = 0;
        playerStatus[i].shipTwoCounter = 0;
        playerStatus[i].shipThreeCounter = 0;
        playerStatus[i].shipsSunk = 0;
        playerStatus[i].canUseArtillery = false;
        playerStatus[i].canUseTorpedo = false;
        initializeBoard(playerStatus[i].board);
        initializeBoard(playerStatus[i].displayBoard);
        initializeShipBoard(playerStatus[i].shipBoard);
        for (int j = 0; j < SHIP_COUNT; j++)
        {
            playerStatus[i].shipsAvailable[j] = true;
            for (int k = 0; k < SIZE; k++)
            {
                playerStatus[i].obscuredCells[j][k] = false; // Set all cells to not obscured
            }
        }
    }
    // Randomly getting player to start
    puts("Let's see who goes first.");
    randomNumber = randomFirstPlayer();
    waitFor(3);
    int player1 = randomNumber;
    int bot = (player1 + 1) % 2;
    // Ship placing phase
    if (player1 == 0)
    {
        printf("%s goes first!\n", name);
        waitFor(2);
        clearScreen();
        printf("%s, PLACE YOUR SHIPS:\n\n", name);
        printBoard(playerStatus[player1].board);
        while (playerStatus[player1].shipsAvailable[0] || playerStatus[player1].shipsAvailable[1] || playerStatus[player1].shipsAvailable[2] || playerStatus[player1].shipsAvailable[3])
        {
            displayAvailableShips(playerStatus, player1);
        }
        waitFor(1);
        puts("NICE PLACEMENTS.\n");
        waitFor(1);
        puts("SWITCHING TURNS.");
        waitFor(3);
        clearScreen();
        printf("Bot is placing ships...\n");
        for (int i = 2; i < 6; i++)
        {
            placeBotShip(playerStatus[bot].board, playerStatus[bot].shipBoard, i);
        }
        waitFor(3);
        printf("Bot placed his ships and is ready for war!!\n");
        waitFor(1);
        puts("LAUNCHING GAME...");
        waitFor(3);
        while (true)
        {
            clearScreen();
            printf("%s's turn!\n\n", name);
            waitFor(1);
            printf("This is your board %s.\n\n", name);
            printBoard(playerStatus[player1].board);

            printf("This is the opponent's board (your view):\n");
            printBoard(playerStatus[player1].displayBoard);

            displayAvailableMoves(playerStatus, player1, bot);

            if (playerStatus[player1].shipsSunk > 0)
                printf("\nShips sunk so far:\n");
            checkSunkShips(playerStatus, bot, player1);

            if (checkWin(playerStatus[bot].board))
                break;
            waitFor(3);
            clearScreen();
            printf("SWITCHING TURNS.\n");
            waitFor(2);
            clearScreen();
            printf("Bots' turn.\n");
            waitFor(1);
            printf("Bot is thinking about it's move...\n");
            waitFor(2);
            botMedium(playerStatus, player1, bot);
            waitFor(1);
            if (playerStatus[bot].shipsSunk > 0)
                printf("\nBot has sunk so far:\n");
            checkSunkShips(playerStatus, player1, bot);
            waitFor(2);
            clearScreen();
            if (checkWin(playerStatus[player1].board))
                break;
            printf("SWITCHING TURNS.\n");
            waitFor(2);
        }
    }
    else
    {
        printf("Bot goes first.\n");
        waitFor(2);
        clearScreen();
        printf("Bot is placing ships...\n");
        for (int i = 2; i < 6; i++)
        {
            placeBotShip(playerStatus[bot].board, playerStatus[bot].shipBoard, i);
        }
        waitFor(2);
        printf("Bot placed his ships and is ready for war!!\n");
        waitFor(1);
        puts("SWITCHING TURNS.");
        waitFor(2);
        clearScreen();
        printf("%s, PLACE YOUR SHIPS:\n\n", name);
        printBoard(playerStatus[player1].board);
        while (playerStatus[player1].shipsAvailable[0] || playerStatus[player1].shipsAvailable[1] || playerStatus[player1].shipsAvailable[2] || playerStatus[player1].shipsAvailable[3])
        {
            displayAvailableShips(playerStatus, player1);
        }
        waitFor(1);
        puts("NICE PLACEMENTS.\n");
        waitFor(1);
        puts("LAUNCHING GAME...");
        waitFor(3);
        while (true)
        {
            clearScreen();
            printf("Bots' turn.\n");
            waitFor(1);
            printf("Bot is thinking about it's move...\n");
            waitFor(2);
            botMedium(playerStatus, player1, bot);
            if (playerStatus[bot].shipsSunk > 0)
                printf("\nBot has sunk so far:\n");
            checkSunkShips(playerStatus, player1, bot);
            waitFor(2);
            clearScreen();
            if (checkWin(playerStatus[player1].board))
                break;
            printf("SWITCHING TURNS.\n");
            waitFor(2);
            clearScreen();
            printf("%s's turn!\n\n", name);
            waitFor(1);
            printf("This is your board %s.\n\n", name);
            printBoard(playerStatus[player1].board);

            printf("This is the opponent's board (your view):\n");
            printBoard(playerStatus[player1].displayBoard);

            displayAvailableMoves(playerStatus, player1, bot);

            if (playerStatus[player1].shipsSunk > 0)
                printf("\nShips sunk so far:\n");
            checkSunkShips(playerStatus, bot, player1);

            if (checkWin(playerStatus[bot].board))
                break;
            waitFor(3);
        }
    }
    return 0;
}

// Functions implementation

// Requires: char[]
// Effects: fills name[] with player name
void getPlayerName(char name[20])
{
    printf("Enter your name: ");
    scanf("%s", name);
}
// Requires: char[]
// Effects: returns int such as: 1: easy, 2: medium, 3: hard
int getDifficulity(char difficulity[])
{
    int c;
    printf("Please enter a tracking difficulty level: E --D Easy, M--D Medium, H --D Hard.\n");
    scanf("%s", difficulity);
    while (strlen(difficulity) > 1 || difficulity[0] != 'E' && difficulity[0] != 'M' && difficulity[0] != 'H' && difficulity[0] != 'e' && difficulity[0] != 'm' && difficulity[0] != 'h')
    {
        printf("The input you entered is invalid. Please enter: E --D Easy, M--D Medium, H --D Hard.\n");
        scanf("%s", difficulity);
    }
    switch (difficulity[0])
    {
    case 'E' | 'e':
        puts("You chose Easy Mode. Let's Play!");
        return 1;
        break;
    case 'M' | 'm':
        puts("You chose Medium Mode. Let's Play!");
        return 2;
        break;
    case 'H' | 'h':
        puts("You chose Hard Mode. Let's Play!");
        return 3;
        break;
    default:
        break;
    }
    return 0;
}
// Requires: char board[SIZE][SIZE], int shipBoard[SIZE][SIZE], int size
// Effects: The bot places its ships after checking the coordinates and the size of the ship
void placeBotShip(char board[SIZE][SIZE], int shipBoard[SIZE][SIZE], int size)
{
    bool placed = false;
    while (!placed)
    {
        int r = rand() % 2;
        int letter = rand() % SIZE;
        int number = rand() % SIZE;

        if (validateCoordinates(letter, number))
        {
            if (r == 0)
            {
                if (number + size <= SIZE && checkPlacement(board, letter, number, size, true))
                {
                    for (int j = 0; j < size; j++)
                    {
                        board[letter][number + j] = 'S';
                        shipBoard[letter][number + j] = size;
                    }
                    placed = true;
                }
            }
            else
            {
                if (letter + size <= SIZE && checkPlacement(board, letter, number, size, false))
                {

                    for (int j = 0; j < size; j++)
                    {
                        board[letter + j][number] = 'S';
                        shipBoard[letter + j][number] = size;
                    }
                    placed = true;
                }
            }
        }
    }
}
// Requires: char board[SIZE][SIZE]
// Effects: Initializes board with water (~)
void initializeBoard(char board[SIZE][SIZE])
{
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            board[i][j] = '~';
        }
    }
}
// Requires: int shipBoard[SIZE][SIZE]
// Requires: Initializes shipboard with 0s
void initializeShipBoard(int shipBoard[SIZE][SIZE])
{
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
            shipBoard[i][j] = 0;
    }
}
// Requires: char board[SIZE][SIZE]
// Effects: Prints the board
void printBoard(char board[SIZE][SIZE])
{
    printf("   A B C D E F G H I J\n"); // Column headers
    for (int i = 0; i < SIZE; i++)
    {
        printf("%2d", i + 1); // Row numbers without space for alignment
        for (int j = 0; j < SIZE; j++)
        {
            char cell = board[i][j];
            if (cell == 'S')
                printf(" S"); // Show ship placement
            else if (cell == 'X')
                printf(" *"); // Shows Hit
            else if (cell == 'o')
                printf(" o"); // Shows Miss
            // else if (cell == 'o')
            // printf(" ~"); // Hidden in Hard mode
            else
                printf(" ~"); // Water
        }
        printf("\n");
    }
    printf("\n");
}
// Requires: PlayerStatus playerStatus[], int player
// Effects: displays to the player whish ships can be placed with their sizes
void displayAvailableShips(PlayerStatus playerStatus[], int player)
{
    printf("Available ships to place:\n");
    if (playerStatus[player].shipsAvailable[0])
        printf("1. CARRIER (Size: %d)\n", CARRIER);
    if (playerStatus[player].shipsAvailable[1])
        printf("2. BATTLESHIP (Size: %d)\n", BATTLESHIP);
    if (playerStatus[player].shipsAvailable[2])
        printf("3. DESTROYER (Size: %d)\n", DESTROYER);
    if (playerStatus[player].shipsAvailable[3])
        printf("4. SUBMARINE (Size: %d)\n", SUBMARINE);

    int choice;
    while (true)
    { // Infinite loop until a valid input is received
        printf("Select a ship to place (enter the number): ");

        // Read input and check if it's valid integer
        if (scanf("%d", &choice) != 1)
        {
            printf("Invalid input. Please enter a number.\n");
            while (getchar() != '\n')
                ; // to clear input buffer (gpt)
            continue;
        }
        if (choice < 1 || choice > SHIP_COUNT)
        {
            printf("Invalid choice. Please select a valid ship number.\n");
            continue;
        }
        switch (choice)
        {
        case 1:
            if (playerStatus[player].shipsAvailable[0])
            {
                placeShip(playerStatus[player].board, playerStatus[player].shipBoard, CARRIER);
                playerStatus[player].shipsAvailable[0] = false;
            }
            else
            {
                printf("CARRIER is not available.\n");
            }
            break;
        case 2:
            if (playerStatus[player].shipsAvailable[1])
            {
                placeShip(playerStatus[player].board, playerStatus[player].shipBoard, BATTLESHIP);
                playerStatus[player].shipsAvailable[1] = false;
            }
            else
            {
                printf("BATTLESHIP is not available.\n");
            }
            break;
        case 3:
            if (playerStatus[player].shipsAvailable[2])
            {
                placeShip(playerStatus[player].board, playerStatus[player].shipBoard, DESTROYER);
                playerStatus[player].shipsAvailable[2] = false;
            }
            else
            {
                printf("DESTROYER is not available.\n");
            }
            break;
        case 4:
            if (playerStatus[player].shipsAvailable[3])
            {
                placeShip(playerStatus[player].board, playerStatus[player].shipBoard, SUBMARINE);
                playerStatus[player].shipsAvailable[3] = false;
            }
            else
            {
                printf("SUBMARINE is not available.\n");
            }
            break;
        }
        break;
    }
}
// Requires: char board[SIZE][SIZE], int shipBoard[SIZE][SIZE], enum ShipSize size
// Effects: places the ships after checking the coordinates and the size of the ship
void placeShip(char board[SIZE][SIZE], int shipBoard[SIZE][SIZE], enum ShipSize size)
{
    bool placed = false;
    while (!placed)
    {
        int x, y;
        char direction;
        printf("Enter the coordinates for your ship of size %d (e.g., A1 H): ", size);
        char coord[3];
        scanf(" %s %c", coord, &direction);

        if (strlen(coord) < 2 && strlen(coord) > 3 && coord[1] == '1' && coord[2] != '0')
        {
            printf("Invalid coordinates. Please use the format A1 or B10.\n");
            continue;
        }
        y = toupper(coord[0]) - 'A';
        x = atoi(&coord[1]) - 1;
        validateCoordinates(x, y);
        bool horizontal = (direction == 'H' || direction == 'h');
        bool vertical = (direction == 'V' || direction == 'v');
        if (horizontal)
        {
            if (y + size <= SIZE && checkPlacement(board, x, y, size, true))
            {
                for (int j = 0; j < size; j++)
                {
                    board[x][y + j] = 'S'; // Place ship
                    shipBoard[x][y + j] = size;
                }
                placed = true;
                puts("\nSHIP PLACED!");
                printBoard(board);
            }
            else
            {
                printf("Invalid placement. Try again.\n");
                continue;
            }
        }
        else if (vertical)
        {
            if (x + size <= SIZE && checkPlacement(board, x, y, size, false))
            {
                for (int j = 0; j < size; j++)
                {
                    board[x + j][y] = 'S'; // Place ship
                    shipBoard[x + j][y] = size;
                }
                puts("SHIP PLACED!");
                printBoard(board);
                placed = true;
            }
            else
            {
                printf("Invalid placement. Try again.\n");
                continue;
            }
        }
        else
        {
            puts("Invalid input. Try again.\n");
            // continue;
        }
    }
}
// Requires: PlayerStatus playerStatus[], int player, int bot
// Effects: displays to the player his only available moves + calls the chosen method
void displayAvailableMoves(PlayerStatus playerStatus[], int player, int bot)
{
    int i = 1;
    printf("Available moves:\n");
    printf("%d. Fire\n", i++);

    if (playerStatus[player].radarSweeps > 0)
        printf("%d. Radar Sweep (Remaining: %d)\n", i++, playerStatus[player].radarSweeps);

    if (playerStatus[player].smokeScreens > 0)
        printf("%d. Smoke Screen (Available: %d)\n", i++, playerStatus[player].smokeScreens);

    if (playerStatus[player].canUseArtillery)
        printf("%d. Artillery\n", i++);

    if (playerStatus[player].canUseTorpedo)
        printf("%d. Torpedo\n", i++);
    int choice;
    while (true)
    {
        printf("Select a move to make (enter the number): ");
        // Read input and check if it's valid integer
        if (scanf("%d", &choice) != 1)
        {
            printf("Invalid input. Please enter a number.\n");
            while (getchar() != '\n')
                ; // to clear input buffer (gpt)
            continue;
        }
        if (choice < 1 || choice > 5)
        {
            printf("Invalid choice. Please select a valid move number.\n");
            continue;
        }
        switch (choice)
        {
        case 1:
            puts("Enter coordinates for the attack:\n");
            char coord[3];
            scanf(" %s", coord);
            int x, y;
            y = toupper(coord[0]) - 'A';
            x = atoi(&coord[1]) - 1;
            if (validateCoordinates(x, y))
                attack(playerStatus[bot].board, playerStatus[player].displayBoard, x, y);
            else
                puts("Invalid coordinates.\nYou lose your turn.");
            break;
        case 2:
            if (playerStatus[player].radarSweeps > 0)
            {
                puts("Enter coordinates for the Radar Sweep:\n");
                char coord[3];
                scanf(" %s", coord);
                int x, y;
                y = toupper(coord[0]) - 'A';
                x = atoi(&coord[1]) - 1;
                if (validateCoordinates(x, y))
                {
                    if (radarSweep(playerStatus, bot, x, y))
                        puts("Enemy ship(s) have been found!");
                    else
                        puts("No ships have been found");
                    playerStatus[player].radarSweeps--; // Decrement if used, no matter result
                }
                else
                    puts("Invalid coordinates.\nYou lose your turn.");
            }
            else
                puts("You don't possess any Radar Sweeps.\nYou lose your turn!");

            break;
        case 3:
            if (playerStatus[player].smokeScreens > 0)
            {
                puts("Enter coordinates for cells you want to hide with Smoke Screen:\n");
                char coord[3];
                scanf(" %s", coord);
                int x, y;
                y = toupper(coord[0]) - 'A';
                x = atoi(&coord[1]) - 1;
                if (validateCoordinates(x, y))
                {
                    smokeScreen(playerStatus, player, x, y);
                    playerStatus[player].smokeScreens -= playerStatus[player].smokeCount; // decrement smokescreens with number of smokes used (smokecount)
                }
                else
                    puts("Invalid coordinates.\nYou lose your turn.");
            }
            else
                puts("You don't possess any Smoke Screens.\nYou lose your turn!");
            break;
        case 4:
            if (playerStatus[player].canUseArtillery)
            {
                puts("Enter coordinates for the Artillery Attack:\n");
                scanf(" %s", coord);
                y = toupper(coord[0]) - 'A';
                x = atoi(&coord[1]) - 1;
                if (validateCoordinates(x, y))
                    artillery(playerStatus[bot].board, playerStatus[player].displayBoard, x, y);
                else
                    puts("Invalid coordinates.\nYou lose your turn.");
            }
            else
                puts("You can't use Artillery.\nYou lose your turn!");
            break;
        case 5:
            if (playerStatus[player].canUseTorpedo)
            {
                char input[3];
                printf("Enter the row/column for the Torpedo Attack (1-10 or A-J): ");
                scanf("%2s", input); // Read up to 2 characters

                // Check if input is a valid number or letter
                if (isdigit(input[0]) && strlen(input) == 1 && input[0] >= '1' && input[0] <= '9') // Valid single-digit number
                    torpedo(playerStatus[bot].board, playerStatus[player].displayBoard, input);
                else if (isdigit(input[0]) && strlen(input) == 2 && input[0] == '1' && input[1] == '0')
                    torpedo(playerStatus[bot].board, playerStatus[player].displayBoard, input);
                else if (isalpha(input[0]) && strlen(input) == 1 && toupper(input[0]) >= 'A' && toupper(input[0]) <= 'J') // Valid letter (A-J or a-j)
                    torpedo(playerStatus[bot].board, playerStatus[player].displayBoard, input);
                else
                    printf("Invalid input. You lose your turn!\n");
            }
            else
                puts("You can't use Torpedo.\nYou lose your turn!");
            break;
        default:
            printf("Invalid choice.");
            break;
        }
        break;
    }
}
// Requires: char board[SIZE][SIZE], char displayBoard[SIZE][SIZE], int x, int y
// Effects: Returns true on hit, false otherwise
bool attack(char board[SIZE][SIZE], char displayBoard[SIZE][SIZE], int x, int y)
{
    if (board[x][y] == 'S')
    {
        board[x][y] = 'X';        // Mark hit on the actual board
        displayBoard[x][y] = 'X'; // Mark hit on the display board
        printf("HIT ON %c%d!\n", 'A' + y, x + 1);
        return true; // Hit
    }
    else if (board[x][y] == '~')
    {
        board[x][y] = 'o';        // Mark miss on the actual board
        displayBoard[x][y] = 'o'; // Mark miss on the display board
        printf("Miss on %c%d.\n", 'A' + y, x + 1);
        return false; // Miss
    }
    else if (board[x][y] == 'X' || board[x][y] == 'o') // Already attacked
    {
        printf("%c%d was already attacked.\n", 'A' + y, x + 1);
        return false; // No action taken
    }
    else
        printf("%c", board[x][y]);
    return false;
}
// Requires: PlayerStatus playerStatus[], int opponent, int x, int y
// Effects: Returns true if there exists a ship in the 2x2 area scanned, false otherwise
bool radarSweep(PlayerStatus playerStatus[], int opponent, int x, int y)
{
    for (int i = x; i <= x + 1; i++) // Loop over the x-axis (2x2 area)
    {
        for (int j = y; j <= y + 1; j++) // Loop over the y-axis (2x2 area)
        {
            // Check if i, j are within bounds of the board
            if (!validateCoordinates(i, j))
            {
                continue; // Skip out-of-bounds cells
            }
            if (playerStatus[opponent].obscuredCells[i][j])
            {
                continue; // If the cell is obscured by a smoke screen, treat as a miss
            }
            // Check if a ship is found
            if (playerStatus[opponent].board[i][j] == 'S')
            {
                return true; // A ship is found
            }
        }
    }
    return false;
}
// Requires: PlayerStatus playerStatus[], int player, int x, int y
// Effects: Obscures a 2x2 area
bool smokeScreen(PlayerStatus playerStatus[], int player, int x, int y)
{
    for (int i = x; i <= x + 1; i++)
    {
        for (int j = y; j <= y + 1; j++)
            playerStatus[player].obscuredCells[i][j] = true; // "Hide" 2x2 area
    }
    printf("Smoke screen applied.\n");
    playerStatus[player].smokeScreens--;
    playerStatus[player].smokeCount++;
    return true;
}
// Requires: char opponentBoard[SIZE][SIZE], char displayBoard[SIZE][SIZE], int x, int y
// Effects: Calls attack method on a 2x2 area
void artillery(char opponentBoard[SIZE][SIZE], char displayBoard[SIZE][SIZE], int x, int y)
{
    for (int i = x; i <= x + 1; i++)
    {
        for (int j = y; j <= y + 1; j++)
        {
            if (i < SIZE && j < SIZE)
                attack(opponentBoard, displayBoard, i, j);
        }
    }
}
// Requires: char opponentBoard[SIZE][SIZE], char displayBoard[SIZE][SIZE], char *input
// Effects: Calls attack method on row/column
void torpedo(char opponentBoard[SIZE][SIZE], char displayBoard[SIZE][SIZE], char *input)
{
    if (isdigit(input[0]) && strlen(input) == 1 && input[0] >= '1' && input[0] <= '9')
    {
        int row = atoi(input) - 1; // Convert the full string to an integer
        if (row >= 0 && row < SIZE)
        {
            for (int j = 0; j < SIZE; j++)
                attack(opponentBoard, displayBoard, row, j);
        }
    }
    else if (isdigit(input[0]) && strlen(input) == 2 && input[0] == '1' && input[1] == '0')
    {
        int row = atoi(input) - 1;
        for (int j = 0; j < SIZE; j++)
            attack(opponentBoard, displayBoard, row, j);
    }
    else if (isalpha(input[0]) && strlen(input) == 1) // Letters A-J only
    {
        int col = toupper(input[0]) - 'A';
        if (col >= 0 && col < SIZE)
        {
            for (int i = 0; i < SIZE; i++)
                attack(opponentBoard, displayBoard, i, col);
        }
    }
}
// Requires: playerStatus[], int player, int bot
// Effects: Checks and updates shipSunk counter + announces what ships have been sunk, refreshes certain abilities
void checkSunkShips(PlayerStatus playerStatus[], int player, int bot)
{
    int count = 0;
    enum ShipSize sizes[] = {CARRIER, BATTLESHIP, DESTROYER, SUBMARINE};
    for (int i = 0; i < SHIP_COUNT; i++) // Iterate through all ship sizes
    {
        int size = sizes[i];
        bool shipSunk = false;

        for (int x = 0; x < SIZE && !shipSunk; x++) // Search rows
        {
            for (int y = 0; y < SIZE; y++) // Search columns
            {
                int hCounter = 0, vCounter = 0;

                // Check horizontally
                for (int k = 0; k < size && y + k < SIZE; k++)
                {
                    if (playerStatus[player].shipBoard[x][y + k] == size && playerStatus[player].board[x][y + k] == 'X')
                        hCounter++;
                    else
                        break;
                }

                // Check vertically
                for (int k = 0; k < size && x + k < SIZE; k++)
                {
                    if (playerStatus[player].shipBoard[x + k][y] == size && playerStatus[player].board[x + k][y] == 'X')
                        vCounter++;
                    else
                        break;
                }
                if (hCounter == size || vCounter == size)
                {
                    count++;
                    printf("Ship of size %d has been sunk!\n", size);
                    shipSunk = true;
                    break; // Stop searching for this ship
                }
            }
        }
    }
    playerStatus[bot].shipsSunk = count;
    playerStatus[bot].smokeScreens = playerStatus[bot].shipsSunk - playerStatus[bot].smokeCount;
    if (playerStatus[bot].shipsSunk == 3 && playerStatus[bot].counter < 1)
    {
        playerStatus[bot].counter = 1;
        playerStatus[bot].canUseTorpedo = true;
    }
    else
    {
        playerStatus[bot].canUseTorpedo = false;
    }
    if (playerStatus[bot].shipsSunk == 1 && playerStatus[bot].shipOneCounter < 1)
    {
        playerStatus[bot].shipOneCounter = 1;
        playerStatus[bot].canUseArtillery = true;
    }
    else if (playerStatus[bot].shipsSunk == 2 && playerStatus[bot].shipTwoCounter < 1)
    {
        playerStatus[bot].shipTwoCounter = 1;
        playerStatus[bot].canUseArtillery = true;
    }
    else if (playerStatus[bot].shipsSunk == 3 && playerStatus[bot].shipThreeCounter < 1)
    {
        playerStatus[bot].shipThreeCounter = 1;
        playerStatus[bot].canUseArtillery = true;
    }
    else
    {
        playerStatus[bot].canUseArtillery = false;
    }
}
// Requires: opponentBoard[SIZE][SIZE]
// Effects: Returns true if no ships have been detected on opponent board, false otherwise
bool checkWin(char opponentBoard[SIZE][SIZE])
{
    for (int i = 0; i < SIZE; i++)
    {
        for (int j = 0; j < SIZE; j++)
        {
            if (opponentBoard[i][j] == 'S')
                return false;
        }
    }
    return true;
}
// Requires: char board[SIZE][SIZE], int x, int y, int size, bool horizontal
// Effects: Returns true if no overlap is detected, false otherwise
bool checkPlacement(char board[SIZE][SIZE], int x, int y, int size, bool horizontal)
{
    for (int j = 0; j < size; j++)
    {
        if (horizontal)
        {
            if (board[x][y + j] != '~')
                return false; // Detected overlap
        }
        else
        {
            if (board[x + j][y] != '~')
                return false; // Detected overlap
        }
    }
    return true; // Can place ship
}
// Requires: int x, y
// Effects: Returns true if coordinates (x, y) are valid, false otherwise
bool validateCoordinates(int x, int y)
{
    return x >= 0 && x < SIZE && y >= 0 && y < SIZE;
}
// Method to randomly get and integer with the rand function and then get the remainder from the % operation(here %2 hence getting either 0 or 1 from any possible int)
int randomFirstPlayer()
{
    return rand() % 2;
}
// Method to add suspense (ex: when gettin first player randomly). No practical use as much as something i wanted to do and got from "stackoverflow"
void waitFor(unsigned int secs)
{
    unsigned int retTime = time(0) + secs; // Get finishing time.
    while (time(0) < retTime)
        ; // Loop until it arrives.
}
// To clear console screen depending on OS, also got from web
void clearScreen()
{
#ifdef _WIN32
    system("cls");
#else
    system("clear");
#endif
}
// Method that prints game instructions
void displayMoveCatalogue()
{
    printf("How to play:\nThe primary objective of the game is to sink all of the opponent's ships. Players take turns performing a single move per turn.\nGameplay features:\n");
    printf("1. Fire: The basic action where a player tries to hit an opponent's ship by guessing a coordinate.\n");
    printf("2. Radar Sweep: Reveals whether there are any opponent ships in a specified 2x2 area of the grid without showing exact locations of ships.\n");
    printf("3. Smoke Screen: Obscures a 2x2 area of the grid by hiding it from radar sweeps.\n");
    printf("4. Artillery: An attack move that works similarly to Fire but targets a 2x2 area.\n");
    printf("5. Torpedo: A powerful attack that targets an entire row or column.\n");
}

void botEasy(PlayerStatus playerStatus[], int player, int bot)
{
    while (true)
    {
        int x = rand() % SIZE;
        int y = rand() % SIZE;
        if (!validateCoordinates(x, y) && botBoard[x][y] == 1)
            continue;
        botBoard[x][y] = 1;

        if (playerStatus[bot].radarSweeps <= 0 && playerStatus[bot].smokeScreens <= 0 && !playerStatus[bot].canUseArtillery && !playerStatus[bot].canUseTorpedo)
        {
            printf("BOT FIRED AT YOUR SHIPS. TAKE COVER!\n");
            waitFor(1);
            attack(playerStatus[player].board, playerStatus[bot].displayBoard, x, y);
            break;
        }
        else if (playerStatus[bot].smokeScreens <= 0 && !playerStatus[bot].canUseArtillery && !playerStatus[bot].canUseTorpedo)
        {
            int move = (rand() % 3) + 1;
            switch (move)
            {
            case 1:
            case 2:
                printf("BOT FIRED AT YOUR SHIPS. TAKE COVER!\n");
                waitFor(1);
                attack(playerStatus[player].board, playerStatus[bot].displayBoard, x, y);
                break;
            case 3:
                printf("BEWARE! BOT IS RADAR SWEEPING NEAR YOUR SHIPS.\n");
                waitFor(1);
                radarSweep(playerStatus, player, x, y);
                break;
            default:
                break;
            }
            break;
        }
        else if (playerStatus[bot].smokeScreens <= 0 && playerStatus[bot].canUseArtillery == true && !playerStatus[bot].canUseTorpedo)
        {
            int move = (rand() % 3) + 1;
            switch (move)
            {
            case 1:
                printf("BOT FIRED AT YOUR SHIPS. TAKE COVER!\n");
                waitFor(1);
                attack(playerStatus[player].board, playerStatus[bot].displayBoard, x, y);
                break;
            case 2:
                printf("BEWARE! BOT IS RADAR SWEEPING NEAR YOUR SHIPS.\n");
                waitFor(1);
                radarSweep(playerStatus, player, x, y);
                break;
            case 3:
                printf("BOT DEPLOYED ARTILLERY MISSILES. WATCH YOUR HEADS!\n");
                waitFor(1);
                artillery(playerStatus[player].board, playerStatus[bot].displayBoard, x, y);
                break;
            default:
                break;
            }
            break;
        }
        else if (playerStatus[bot].smokeScreens <= 0 && !playerStatus[bot].canUseArtillery && playerStatus[bot].canUseTorpedo == true)
        {
            int move = (rand() % 3) + 1;
            switch (move)
            {
            case 1:
                printf("BOT FIRED AT YOUR SHIPS. TAKE COVER!\n");
                waitFor(1);
                attack(playerStatus[player].board, playerStatus[bot].displayBoard, x, y);
                break;
            case 2:
                printf("BEWARE! BOT IS RADAR SWEEPING NEAR YOUR SHIPS.\n");
                waitFor(1);
                radarSweep(playerStatus, player, x, y);
                break;
            case 3:
            {
                char *s = randomTorpedo();
                printf("BOT UNLEASHED DEADLY TORPEDO ATTACK! ALERT RED!!");
                waitFor(1);
                torpedo(playerStatus[player].board, playerStatus[bot].displayBoard, s);
                break;
            }
            default:
                break;
            }
            break;
        }
        else if (playerStatus[bot].canUseArtillery == true && !playerStatus[bot].canUseTorpedo)
        {
            int move = 1 + rand() % 4;
            switch (move)
            {
            case 1:
                printf("BOT FIRED AT YOUR SHIPS. TAKE COVER!\n");
                waitFor(1);
                attack(playerStatus[player].board, playerStatus[bot].displayBoard, x, y);
                break;
            case 2:
                printf("BEWARE! BOT IS RADAR SWEEPING NEAR YOUR SHIPS.\n");
                waitFor(1);
                radarSweep(playerStatus, player, x, y);
                break;
            case 3:
                printf("BOT DEPLOYED ARTILLERY MISSILES. WATCH YOUR HEADS!\n");
                waitFor(1);
                artillery(playerStatus[player].board, playerStatus[bot].displayBoard, x, y);
                break;
            case 4:
                printf("BOT IS ATTEMPTING TO SMOKE SCREEN HIS SHIPS\n");
                waitFor(1);
                smokeScreen(playerStatus, bot, x, y);
                break;
            default:
                break;
            }
            break;
        }
        else if (!playerStatus[bot].canUseArtillery && playerStatus[bot].canUseTorpedo == true)
        {
            int move = (rand() % 4) + 1;
            switch (move)
            {
            case 1:
                printf("BOT FIRED AT YOUR SHIPS. TAKE COVER!\n");
                waitFor(1);
                attack(playerStatus[player].board, playerStatus[bot].displayBoard, x, y);
                break;
            case 2:
                printf("BEWARE! BOT IS RADAR SWEEPING NEAR YOUR SHIPS.\n");
                waitFor(1);
                radarSweep(playerStatus, player, x, y);
                break;
            case 3:
            {
                char *s = randomTorpedo();
                printf("BOT UNLEASHED DEADLY TORPEDO ATTACK! ALERT RED!!\n");
                waitFor(1);
                torpedo(playerStatus[player].board, playerStatus[bot].displayBoard, s);
                break;
            }
            case 4:
                printf("BOT IS ATTEMPTING TO SMOKE SCREEN HIS SHIP\n");
                waitFor(1);
                smokeScreen(playerStatus, bot, x, y);
                break;
            default:
                break;
            }
            break;
        }
        else if (playerStatus[bot].canUseArtillery && playerStatus[bot].canUseTorpedo)
        {
            int move = (rand() % 5) + 1;
            switch (move)
            {
            case 1:
                printf("BOT FIRED AT YOUR SHIPS. TAKE COVER!\n");
                waitFor(1);
                attack(playerStatus[player].board, playerStatus[bot].displayBoard, x, y);
                break;
            case 2:
                printf("BEWARE! BOT IS RADAR SWEEPING NEAR YOUR SHIPS.\n");
                waitFor(1);
                radarSweep(playerStatus, player, x, y);
                break;
            case 3:
            {
                char *s = randomTorpedo();
                printf("BOT UNLEASHED DEADLY TORPEDO ATTACK! ALERT RED!!\n");
                waitFor(1);
                torpedo(playerStatus[player].board, playerStatus[bot].displayBoard, s);
                break;
            }
            case 4:
                printf("BOT DEPLOYED ARTILLERY MISSILES. WATCH YOUR HEADS!\n");
                waitFor(1);
                artillery(playerStatus[player].board, playerStatus[bot].displayBoard, x, y);
                break;
            case 5:
                printf("BOT IS ATTEMPTING TO SMOKE SCREEN HIS SHIPS\n");
                waitFor(1);
                smokeScreen(playerStatus, bot, x, y);
                break;
            default:
                break;
            }
            break;
        }
    }
}
void botMedium(PlayerStatus playerStatus[], int player, int bot)
{
    // Prioritize Torpedo and Artillery (80% chance when available)
    if (playerStatus[bot].canUseTorpedo && rand() % 100 < 80)
    {
        // If targeting mode is active (after a hit), prioritize adjacent row/column for torpedo
        char *s;
        if (botStatus.targetingMode)
        {
            // Target the same row or column as the previous hit
            s = randomTorpedoo(botStatus.lastHitX, botStatus.lastHitY);
        }
        else
        {
            // Otherwise, select a random row/column
            s = randomTorpedo();
        }

        printf("BOT UNLEASHED A TORPEDO ATTACK ON %s! BE CAREFUL!\n", s);
        waitFor(1);
        torpedo(playerStatus[player].board, playerStatus[bot].displayBoard, s);
        return;
    }

    if (playerStatus[bot].canUseArtillery && rand() % 100 < 80)
    {
        // If targeting mode is active, artillery should target adjacent cells
        int x, y;
        if (botStatus.targetingMode)
        {
            // Target adjacent cells for artillery (2x2 area)
            int dx[] = {-1, 1, 0, 0}; // Directions: up, down, left, right
            int dy[] = {0, 0, -1, 1};

            // Randomly choose an adjacent direction
            int direction = rand() % 4;
            x = botStatus.lastHitX + dx[direction];
            y = botStatus.lastHitY + dy[direction];

            // Ensure we stay within bounds
            if (!validateCoordinates(x, y))
            {
                x = botStatus.lastHitX;
                y = botStatus.lastHitY;
            }
        }
        else
        {
            // If not targeting, use random coordinates
            x = rand() % SIZE;
            y = rand() % SIZE;
        }

        printf("BOT DEPLOYED ARTILLERY MISSILES AT %c%d. WATCH OUT!\n", 'A' + y, x + 1);
        waitFor(1);
        artillery(playerStatus[player].board, playerStatus[bot].displayBoard, x, y);
        return;
    }

    // Radar Sweep and Smoke Screen (20% chance when available)
    if (playerStatus[bot].radarSweeps > 0 && rand() % 100 < 20)
    {
        int x, y;
        do
        {
            x = rand() % SIZE;
            y = rand() % SIZE;
        } while (botBoard[x][y] != 0);
        printf("BOT IS USING RADAR SWEEP AT %c%d.\n", 'A' + y, x + 1);
        waitFor(1);
        if (radarSweep(playerStatus, player, x, y))
        {
            printf("BOT FOUND A SHIP NEARBY USING RADAR SWEEP!\n");
            botStatus.lastHitX = x;
            botStatus.lastHitY = y;
            botStatus.targetingMode = true;
            return; // Focus on this area first
        }
        else
            printf("BOT'S RADAR SWEEP FOUND NOTHING.\n");
        playerStatus[bot].radarSweeps--;
        return;
    }

    if (playerStatus[bot].smokeScreens > 0 && rand() % 100 < 30)
    {
        // Check for areas with multiple ships and apply smoke screen there
        bool usedSmokeScreen = false;

        for (int x = 0; x < SIZE - 1; x++)
        {
            for (int y = 0; y < SIZE - 1; y++)
            {
                // Check if the 2x2 area has multiple ships
                int shipCount = 0;
                for (int dx = 0; dx < 2; dx++)
                {
                    for (int dy = 0; dy < 2; dy++)
                    {
                        if (playerStatus[bot].board[x + dx][y + dy] == 'S')
                        {
                            shipCount++;
                        }
                    }
                }

                // If there are 2 or more ships in the 2x2 area, apply the smoke screen
                if (shipCount >= 2)
                {
                    printf("BOT IS USING SMOKE SCREEN TO OBSCURE SOME AREA.\n");
                    waitFor(1);
                    smokeScreen(playerStatus, bot, x, y);
                    usedSmokeScreen = true;
                    break;
                }
            }
            if (usedSmokeScreen)
                break;
        }

        // If no high density ship area is found, just use smoke screen randomly
        if (!usedSmokeScreen)
        {
            int x = rand() % SIZE;
            int y = rand() % SIZE;
            printf("BOT IS USING SMOKE SCREEN TO OBSCURE SOME AREA.\n");
            waitFor(1);
            smokeScreen(playerStatus, bot, x, y);
        }
        return;
    }

    // If no abilities used, go into Targeting Mode
    // Targeting Mode: Prioritize adjacent cells if already found hit, hit randomly (like ez bot) otherwise
    if (botStatus.targetingMode)
    {
        int dx[] = {-1, 1, 0, 0}; // Directions: up, down, left, right
        int dy[] = {0, 0, -1, 1};

        for (int i = 0; i < 4; i++)
        {
            int x = botStatus.lastHitX + dx[i];
            int y = botStatus.lastHitY + dy[i];

            // Check if the cell is valid and unvisited
            if (validateCoordinates(x, y) && botBoard[x][y] == 0)
            {
                botBoard[x][y] = 1; // Mark cell as "visited"
                printf("BOT FIRED AT %c%d. TAKE COVER!\n", 'A' + y, x + 1);
                waitFor(1);
                if (attack(playerStatus[player].board, playerStatus[bot].displayBoard, x, y)) // If hit, continue targeting
                {
                    botStatus.lastHitX = x;
                    botStatus.lastHitY = y;
                    return;
                }
                else // If miss reset targeting mode
                {
                    botStatus.targetingMode = false;
                    return;
                }
            }
        }
    }
    // If no abilities are used AND targeting mode fails, randomly attack to find hit
    while (true)
    {
        int x = rand() % SIZE;
        int y = rand() % SIZE;

        if (botBoard[x][y] == 0) // Unattacked cell
        {
            botBoard[x][y] = 1;                                                           // Mark cell as visited
            if (attack(playerStatus[player].board, playerStatus[bot].displayBoard, x, y)) // If hit, prepare for Targeting Mode next turn
            {
                botStatus.lastHitX = x;
                botStatus.lastHitY = y;
                botStatus.targetingMode = true;
            }
            return;
        }
    }
}
// Same as below, but one that takes last hit in consideration
char *randomTorpedoo(int lastHitX, int lastHitY)
{
    static char result[2]; // The result will be either a letter (column) or a number (row)

    // Randomly choose whether to return a column or a row
    if (rand() % 2 == 0)
    {
        // Generate a column (A-J)
        result[0] = 'A' + rand() % 10;
    }
    else
    {
        // Generate a row (1-10)
        result[0] = '1' + rand() % 10;
    }
    result[1] = '\0'; // Null-terminate the string to make it a proper string
    return result;
}
// Helper method for Torpedo method for generating either random row/column
char *randomTorpedo()
{
    static char result[2]; // 1 character

    int choice = rand() % 2; // Randomly choose between 0 (number) or 1 (letter)

    if (choice == 0)
    {
        // Generate a random number (1-10)
        result[0] = '0' + rand() % SIZE;
    }
    else
    {
        // Generate a random letter (A-J)
        result[0] = 'a' + rand() % SIZE;
    }
    result[1] = '\0'; // Null-terminate the string
    return result;
}
